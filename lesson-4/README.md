#Задание №1

Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых трех уроков.
Примечание. Идеальным решением будет:

Было создано 3 варианта кода для реализации задачи:
В одномерном массиве найти сумму элементов, находящихся между минимальным и максимальным элементами. Сами минимальный и максимальный элементы в сумму не включать

Вариант 1: les_4_task_1_1.py
-
- Генерация случайных чисел с помощью random.randint
- Нахождение минимального и максимального индекса в цикле с использованием enumerate
- Суммирование элементов между минимальным и максимальным в цикле с использованием enumerate
    
**Скорость работы для 1000000 чисел: 6.95 sec**

Вариант 2: les_4_task_1_1.py
-
- Генерация случайных чисел с помощью random.randint
- Нахождение минимального и максимального индекса с помощью функций min, max и метода index
- Суммирование элементов между минимальным и максимальным с помощью reduce и среза списка

**Скорость работы для 1000000 чисел: 603 msec**

Вариант 3: les_4_task_1_1.py
-
- Генерация случайных чисел с помощью random.random()
- Нахождение минимального и максимального индекса с помощью функций min, max и метода index
- Суммирование элементов между минимальным и максимальным с помощью функции sum и среза списка

**Скорость работы для 1000000 чисел: 160 msec**

Более детальная информация о анализе можно увидеть в соответствующих файлах

Вывод
-
Самый лучший результат показал вариант №3, за счёт использования более простой генерации псевдослучайных чисел 
и минимизации циклов

#Задание №2

Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
Первый — с помощью алгоритма «Решето Эратосфена».
Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
Второй — без использования «Решета Эратосфена».

`python -m timeit "import les_4_task_2" "les_4_task_2.sieve(10)"
50000 loops, best of 5: 7.24 usec per loop`

`python -m timeit "import les_4_task_2" "les_4_task_2.sieve(100)"
2000 loops, best of 5: 106 usec per loop`

`python -m timeit "import les_4_task_2" "les_4_task_2.sieve(1000)"
200 loops, best of 5: 1.53 msec per loop`

`python -m timeit "import les_4_task_2" "les_4_task_2.prime(10)"`
`50000 loops, best of 5: 6.12 usec per loop`

`python -m timeit "import les_4_task_2" "les_4_task_2.prime(100)"`
`1000 loops, best of 5: 215 usec per loop`

`python -m timeit "import les_4_task_2" "les_4_task_2.prime(1000)"`
`20 loops, best of 5: 14.9 msec per loop`

Вывод
-
Алгоритм Решета Эрастофена работает быстрее при нахождении i-го по счёту простого числа при i > 10.
т.е. на больших нагрузках работает в разы быстрее чем второй алгоритм